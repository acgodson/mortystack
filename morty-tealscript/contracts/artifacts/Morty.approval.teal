#pragma version 9

// This TEAL was generated by TEALScript v0.58.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication()void
//
// Initializes the transaction ID counter when creating the application.
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

createApplication:
	proto 0 0

	// contracts/morty.algo.ts:29
	// this.TxnIDx.value = 1
	byte 0x54786e494478 // "TxnIDx"
	int 1
	app_global_put
	retsub

calculateRoundIndex:
	proto 4 1

	// contracts/morty.algo.ts:39
	// elapsedMilliseconds: uint64 = timestamp - startDate
	frame_dig -2 // timestamp: uint64
	frame_dig -1 // startDate: uint64
	-
	frame_bury -3 // elapsedMilliseconds: uint64

	// contracts/morty.algo.ts:40
	// fullDays: uint64 = elapsedMilliseconds / INTERVAL_MS
	frame_dig -3 // elapsedMilliseconds: uint64
	int 86400000
	/
	frame_bury -4 // fullDays: uint64

	// contracts/morty.algo.ts:41
	// return fullDays + 1;
	frame_dig -4 // fullDays: uint64
	int 1
	+
	retsub

// subscribe(byte[32])uint64[2]
//
// Allows an account to subscribe, setting a subscription period and charging money after the free 1 month period.
// @param account - Public key of the account subscribing.
// @returns The subscription period [startDate, endDate].
abi_route_subscribe:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// account: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute subscribe(byte[32])uint64[2]
	callsub subscribe
	int 1
	return

subscribe:
	proto 3 0

	// if0_condition
	// contracts/morty.algo.ts:50
	// this.subscription(account).exists
	frame_dig -1 // account: byte[32]
	box_len
	swap
	pop
	bz if0_end

// if0_consequent
if0_end:
	// contracts/morty.algo.ts:53
	// startdate: uint64 = globals.latestTimestamp
	global LatestTimestamp
	frame_bury -2 // startdate: uint64

	// contracts/morty.algo.ts:54
	// endDate: uint64 = startdate + 30 * 24 * 60 * 60 * 1000
	frame_dig -2 // startdate: uint64
	int 2592000000
	+
	frame_bury -3 // endDate: uint64

	// contracts/morty.algo.ts:55
	// this.subscription(account).value = [startdate, endDate]
	frame_dig -1 // account: byte[32]
	frame_dig -2 // startdate: uint64
	itob
	frame_dig -3 // endDate: uint64
	itob
	concat
	box_put

	// contracts/morty.algo.ts:56
	// return this.subscription(account).value;
	frame_dig -1 // account: byte[32]
	box_get
	assert
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// createRecord(asset,string,byte[32])byte[32]
//
// Creates a unique seller record based on the account, reference, and asset information.
// @param account - Public key of the seller's account.
// @param ref - Reference string.
// @param asset - Asset associated with the seller's record.
// @returns The unique reference for the seller's record.
abi_route_createRecord:
	byte 0x; dupn 3 // push empty bytes to fill the stack frame for this subroutine's local variables

	// asset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// ref: string
	txna ApplicationArgs 2
	extract 2 0

	// account: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createRecord(asset,string,byte[32])byte[32]
	callsub createRecord
	int 1
	return

createRecord:
	proto 7 0

	// contracts/morty.algo.ts:67
	// assert(asset.creator === this.txn.sender)
	frame_dig -3 // asset: asset
	asset_params_get AssetCreator
	assert
	txn Sender
	==
	assert

	// contracts/morty.algo.ts:70
	// assert(this.subscription(account).exists)
	frame_dig -1 // account: byte[32]
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:71
	// assert(this.subscription(account).value[1] > globals.latestTimestamp)
	frame_dig -1 // account: byte[32]
	box_get
	assert
	extract 8 8
	btoi
	global LatestTimestamp
	>
	assert

	// contracts/morty.algo.ts:72
	// start: uint64 = this.subscription(account).value[0]
	frame_dig -1 // account: byte[32]
	box_get
	assert
	extract 0 8
	btoi
	frame_bury -4 // start: uint64

	// contracts/morty.algo.ts:73
	// end: uint64 = this.subscription(account).value[1]
	frame_dig -1 // account: byte[32]
	box_get
	assert
	extract 8 8
	btoi
	frame_bury -5 // end: uint64

	// contracts/morty.algo.ts:74
	// period: uint64 = start + end
	frame_dig -4 // start: uint64
	frame_dig -5 // end: uint64
	+
	frame_bury -6 // period: uint64

	// contracts/morty.algo.ts:75
	// reference: byte32 = keccak256(ref + period.toString())
	frame_dig -2 // ref: bytes
	frame_dig -6 // period: uint64
	callsub itoa
	concat
	keccak256
	frame_bury -7 // reference: byte32

	// contracts/morty.algo.ts:76
	// assert(!this.sellerRecord(reference).exists)
	frame_dig -7 // reference: byte32
	box_len
	swap
	pop
	!
	assert

	// contracts/morty.algo.ts:77
	// this.sellerRecord(reference).value = []
	frame_dig -7 // reference: byte32
	dup
	box_del
	pop
	byte 0x0000
	box_put

	// contracts/morty.algo.ts:78
	// return reference;
	byte 0x151f7c75
	frame_dig -7 // reference: byte32
	concat
	log
	retsub

// makePayment(address,address,string,byte[32],string,uint64,asset)uint64
//
// Processes a payment transaction, creating a new transaction record and associated metadata.
// @param vault - Asset used for the payment.
// @param amount - Amount of the payment.
// @param description - Description of the payment.
// @param sub - Public key of the subscriber.
// @param sellerRef - Reference string associated with the seller's record.
// @param from - Sender's address.
// @param to - Receiver's address.
// @returns The receipt (asset) for the payment transaction.
abi_route_makePayment:
	byte 0x; dupn 5 // push empty bytes to fill the stack frame for this subroutine's local variables

	// to: address
	txna ApplicationArgs 7
	dup
	len
	int 32
	==
	assert

	// from: address
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// sellerRef: string
	txna ApplicationArgs 5
	extract 2 0

	// sub: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// description: string
	txna ApplicationArgs 3
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// vault: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute makePayment(address,address,string,byte[32],string,uint64,asset)uint64
	callsub makePayment
	int 1
	return

makePayment:
	proto 13 0

	// contracts/morty.algo.ts:101
	// verifyTxn(this.txn, { sender: from })
	// verify sender
	txn Sender
	frame_dig -6 // from: address
	==
	assert

	// contracts/morty.algo.ts:102
	// txnID: uint64 = this.TxnIDx.value
	byte 0x54786e494478 // "TxnIDx"
	app_global_get
	frame_bury -8 // txnID: uint64

	// contracts/morty.algo.ts:103
	// assert(!this.transactionDetails(txnID).exists)
	frame_dig -8 // txnID: uint64
	itob
	box_len
	swap
	pop
	!
	assert

	// contracts/morty.algo.ts:104
	// assert(this.subscription(sub).exists)
	frame_dig -4 // sub: byte[32]
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:105
	// assert(this.subscription(sub).value[1] > globals.latestTimestamp)
	frame_dig -4 // sub: byte[32]
	box_get
	assert
	extract 8 8
	btoi
	global LatestTimestamp
	>
	assert

	// contracts/morty.algo.ts:106
	// period: uint64 =
	//       this.subscription(sub).value[0] + this.subscription(sub).value[1]
	frame_dig -4 // sub: byte[32]
	box_get
	assert
	extract 0 8
	btoi
	frame_dig -4 // sub: byte[32]
	box_get
	assert
	extract 8 8
	btoi
	+
	frame_bury -9 // period: uint64

	// contracts/morty.algo.ts:108
	// recordID: byte32 = keccak256(sellerRef + period.toString())
	frame_dig -5 // sellerRef: bytes
	frame_dig -9 // period: uint64
	callsub itoa
	concat
	keccak256
	frame_bury -10 // recordID: byte32

	// contracts/morty.algo.ts:109
	// assert(this.sellerRecord(recordID).exists)
	frame_dig -10 // recordID: byte32
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:112
	// sendAssetTransfer({
	//       xferAsset: vault,
	//       assetAmount: 0,
	//       fee: 10000,
	//       assetReceiver: this.app.address,
	//       sender: this.app.address,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/morty.algo.ts:113
	// xferAsset: vault
	frame_dig -1 // vault: asset
	itxn_field XferAsset

	// contracts/morty.algo.ts:114
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts/morty.algo.ts:115
	// fee: 10000
	int 10000
	itxn_field Fee

	// contracts/morty.algo.ts:116
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/morty.algo.ts:117
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// Submit inner transaction
	itxn_submit

	// contracts/morty.algo.ts:120
	// roundID: uint64 = this.calculateRoundIndex(
	//       this.subscription(sub).value[0],
	//       globals.latestTimestamp
	//     )
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables
	global LatestTimestamp
	frame_dig -4 // sub: byte[32]
	box_get
	assert
	extract 0 8
	btoi
	callsub calculateRoundIndex
	frame_bury -11 // roundID: uint64

	// contracts/morty.algo.ts:125
	// receipt: Asset = sendAssetCreation({
	//       configAssetTotal: 1,
	//       configAssetFreeze: this.app.address,
	//       configAssetClawback: this.app.address,
	//       sender: this.app.address,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/morty.algo.ts:126
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/morty.algo.ts:127
	// configAssetFreeze: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetFreeze

	// contracts/morty.algo.ts:128
	// configAssetClawback: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetClawback

	// contracts/morty.algo.ts:129
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -12 // receipt: asset

	// contracts/morty.algo.ts:132
	// metadata: metadata = {
	//       vault: vault,
	//       value: amount,
	//       description: description,
	//       status: 0,
	//       receipt: receipt,
	//       to: to,
	//       from: this.txn.sender,
	//       rIdx: roundID,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x006a // initial head offset
	frame_dig -1 // vault: asset
	itob
	callsub process_static_tuple_element
	frame_dig -2 // amount: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -3 // description: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	frame_dig -12 // receipt: asset
	itob
	callsub process_static_tuple_element
	frame_dig -7 // to: address
	callsub process_static_tuple_element
	txn Sender
	callsub process_static_tuple_element
	frame_dig -11 // roundID: uint64
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -13 // metadata: metadata

	// contracts/morty.algo.ts:143
	// this.transactionDetails(txnID).value = metadata
	frame_dig -8 // txnID: uint64
	itob
	dup
	box_del
	pop
	frame_dig -13 // metadata: metadata
	box_put

	// contracts/morty.algo.ts:144
	// this.sellerRecord(recordID).value.push(txnID)
	frame_dig -10 // recordID: byte32
	box_get
	assert
	extract 2 0
	frame_dig -8 // txnID: uint64
	itob
	concat
	frame_dig -10 // recordID: byte32
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/morty.algo.ts:145
	// this.TxnIDx.value = this.TxnIDx.value + 1
	byte 0x54786e494478 // "TxnIDx"
	byte 0x54786e494478 // "TxnIDx"
	app_global_get
	int 1
	+
	app_global_put

	// contracts/morty.algo.ts:146
	// return receipt;
	frame_dig -12 // receipt: asset
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// claimPayment(pay,asset,uint64)void
//
// Handles the payment claim process, verifying the seller's signature and transferring assets to the seller.
// @param txID - Transaction ID of the payment transaction.
// @param payASA - Asset associated with the payment.
// @param txn - Payment transaction details.
abi_route_claimPayment:
	byte 0x; dupn 3 // push empty bytes to fill the stack frame for this subroutine's local variables

	// txn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// payASA: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// txID: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimPayment(pay,asset,uint64)void
	callsub claimPayment
	int 1
	return

claimPayment:
	proto 7 0

	// contracts/morty.algo.ts:157
	// assert(this.transactionDetails(txID).exists)
	frame_dig -1 // txID: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:158
	// pubKey: Address = this.transactionDetails(txID).value.to
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 34 32
	frame_bury -4 // pubKey: address

	// contracts/morty.algo.ts:159
	// assert(this.txn.sender === pubKey)
	txn Sender
	frame_dig -4 // pubKey: address
	==
	assert

	// contracts/morty.algo.ts:160
	// verifyTxn(txn, { receiver: pubKey })
	// verify receiver
	frame_dig -3 // txn: pay
	gtxns Receiver
	frame_dig -4 // pubKey: address
	==
	assert

	// contracts/morty.algo.ts:161
	// status: uint64 = this.transactionDetails(txID).value.status
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	frame_bury -5 // status: uint64

	// contracts/morty.algo.ts:162
	// assert(status === 0)
	frame_dig -5 // status: uint64
	int 0
	==
	assert

	// contracts/morty.algo.ts:163
	// asset: Asset = this.transactionDetails(txID).value.vault
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 8
	btoi
	frame_bury -6 // asset: asset

	// contracts/morty.algo.ts:164
	// assert(payASA === asset)
	frame_dig -2 // payASA: asset
	frame_dig -6 // asset: asset
	==
	assert

	// contracts/morty.algo.ts:165
	// amount: uint64 = this.transactionDetails(txID).value.value
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 8 8
	btoi
	frame_bury -7 // amount: uint64

	// contracts/morty.algo.ts:166
	// assert(amount > 0)
	frame_dig -7 // amount: uint64
	int 0
	>
	assert

	// contracts/morty.algo.ts:169
	// this.pendingGroup.addAssetTransfer({
	//       xferAsset: asset,
	//       assetAmount: amount,
	//       assetReceiver: this.txn.sender,
	//       fee: 10000,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/morty.algo.ts:170
	// xferAsset: asset
	frame_dig -6 // asset: asset
	itxn_field XferAsset

	// contracts/morty.algo.ts:171
	// assetAmount: amount
	frame_dig -7 // amount: uint64
	itxn_field AssetAmount

	// contracts/morty.algo.ts:172
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/morty.algo.ts:173
	// fee: 10000
	int 10000
	itxn_field Fee

	// contracts/morty.algo.ts:176
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/morty.algo.ts:178
	// this.transactionDetails(txID).value.value = 0
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 8
	byte 0x0000000000000000
	replace3
	frame_dig -1 // txID: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

	// contracts/morty.algo.ts:179
	// this.transactionDetails(txID).value.status = 1
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 18
	byte 0x0000000000000001
	replace3
	frame_dig -1 // txID: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// claimReceipt(asset,uint64)void
abi_route_claimReceipt:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// receipt: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// txID: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimReceipt(asset,uint64)void
	callsub claimReceipt
	int 1
	return

claimReceipt:
	proto 3 0

	// contracts/morty.algo.ts:183
	// assert(this.transactionDetails(txID).exists)
	frame_dig -1 // txID: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:184
	// asset: Asset = this.transactionDetails(txID).value.receipt
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 26 8
	btoi
	frame_bury -3 // asset: asset

	// contracts/morty.algo.ts:185
	// assert(asset !== Asset.zeroIndex)
	frame_dig -3 // asset: asset
	int 0
	!=
	assert

	// contracts/morty.algo.ts:188
	// sendAssetTransfer({
	//       xferAsset: receipt,
	//       assetAmount: 0,
	//       fee: 10000,
	//       assetReceiver: this.txn.sender,
	//       sender: this.txn.sender,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/morty.algo.ts:189
	// xferAsset: receipt
	frame_dig -2 // receipt: asset
	itxn_field XferAsset

	// contracts/morty.algo.ts:190
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts/morty.algo.ts:191
	// fee: 10000
	int 10000
	itxn_field Fee

	// contracts/morty.algo.ts:192
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/morty.algo.ts:193
	// sender: this.txn.sender
	txn Sender
	itxn_field Sender

	// Submit inner transaction
	itxn_submit
	retsub

// getLastSubscription(byte[32])uint64[2]
//
// Retrieves the current subscription period for a given account.
// @param acc - Public key of the account.
// @returns The subscription period [startDate, endDate].
abi_route_getLastSubscription:
	// acc: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getLastSubscription(byte[32])uint64[2]
	callsub getLastSubscription
	int 1
	return

getLastSubscription:
	proto 1 0

	// contracts/morty.algo.ts:205
	// return this.subscription(acc).value;
	frame_dig -1 // acc: byte[32]
	box_get
	assert
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getReceipt(uint64)uint64
//
// Retrieves the receipt (asset) associated with a given transaction ID.
// @param txID - Transaction ID.
// @returns The receipt (asset) for the specified transaction.
abi_route_getReceipt:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// txID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getReceipt(uint64)uint64
	callsub getReceipt
	int 1
	return

getReceipt:
	proto 2 0

	// contracts/morty.algo.ts:214
	// receipt: Asset = this.transactionDetails(txID).value.receipt
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 26 8
	btoi
	frame_bury -2 // receipt: asset

	// contracts/morty.algo.ts:215
	// return receipt;
	frame_dig -2 // receipt: asset
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getVault(uint64)uint64
//
// Retrieves the vault (asset) associated with a given transaction ID.
// @param txID - Transaction ID.
// @returns The vault (asset) for the specified transaction.
abi_route_getVault:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// txID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVault(uint64)uint64
	callsub getVault
	int 1
	return

getVault:
	proto 2 0

	// contracts/morty.algo.ts:224
	// receipt: Asset = this.transactionDetails(txID).value.vault
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 8
	btoi
	frame_bury -2 // receipt: asset

	// contracts/morty.algo.ts:225
	// return receipt;
	frame_dig -2 // receipt: asset
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getRecordReference(string,uint64,uint64)byte[32]
//
// Generates a unique record reference based on start and end timestamps and a reference string.
// @param start - Start timestamp.
// @param end - End timestamp.
// @param ref - Reference string.
// @returns The unique reference for the seller's record.
abi_route_getRecordReference:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// ref: string
	txna ApplicationArgs 3
	extract 2 0

	// end: uint64
	txna ApplicationArgs 2
	btoi

	// start: uint64
	txna ApplicationArgs 1
	btoi

	// execute getRecordReference(string,uint64,uint64)byte[32]
	callsub getRecordReference
	int 1
	return

getRecordReference:
	proto 5 0

	// contracts/morty.algo.ts:236
	// period: uint64 = start + end
	frame_dig -1 // start: uint64
	frame_dig -2 // end: uint64
	+
	frame_bury -4 // period: uint64

	// contracts/morty.algo.ts:237
	// reference: byte32 = keccak256(ref + period.toString())
	frame_dig -3 // ref: bytes
	frame_dig -4 // period: uint64
	callsub itoa
	concat
	keccak256
	frame_bury -5 // reference: byte32

	// contracts/morty.algo.ts:238
	// return reference;
	byte 0x151f7c75
	frame_dig -5 // reference: byte32
	concat
	log
	retsub

// getMyTxnIDs(byte[32])uint64[]
//
// Retrieves transaction IDs associated with a specific record reference.
// @param reference - Unique reference for the seller's record.
// @returns An array of transaction IDs associated with the specified record reference.
abi_route_getMyTxnIDs:
	// reference: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getMyTxnIDs(byte[32])uint64[]
	callsub getMyTxnIDs
	int 1
	return

getMyTxnIDs:
	proto 1 0

	// contracts/morty.algo.ts:247
	// assert(this.sellerRecord(reference).exists)
	frame_dig -1 // reference: byte[32]
	box_len
	swap
	pop
	assert

	// contracts/morty.algo.ts:248
	// return this.sellerRecord(reference).value;
	frame_dig -1 // reference: byte[32]
	box_get
	assert
	extract 2 0
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// getTxnInfo(uint64)(string,uint64,uint64)
//
// Retrieves transaction information including description, status, and round index for a given transaction ID.
// @param txID - Transaction ID.
// @returns Transaction information object { description, status, rIdx }.
abi_route_getTxnInfo:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// txID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getTxnInfo(uint64)(string,uint64,uint64)
	callsub getTxnInfo
	int 1
	return

getTxnInfo:
	proto 2 0

	// contracts/morty.algo.ts:261
	// txnInfo: {
	//       description: string;
	//       status: uint64;
	//       rIdx: uint64;
	//     } = {
	//       description: this.transactionDetails(txID).value.description,
	//       status: this.transactionDetails(txID).value.status,
	//       rIdx: this.transactionDetails(txID).value.rIdx,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0012 // initial head offset
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	int 16
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 18 8
	btoi
	itob
	callsub process_static_tuple_element
	frame_dig -1 // txID: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 98 8
	btoi
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -2 // txnInfo: { description: string; status: uint64; rIdx: uint64; }

	// contracts/morty.algo.ts:270
	// return txnInfo;
	byte 0x151f7c75
	frame_dig -2 // txnInfo: { description: string; status: uint64; rIdx: uint64; }
	concat
	log
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "subscribe(byte[32])uint64[2]"
	method "createRecord(byte[32],string,asset)byte[32]"
	method "makePayment(asset,uint64,string,byte[32],string,address,address)uint64"
	method "claimPayment(uint64,asset,pay)void"
	method "claimReceipt(uint64,asset)void"
	method "getLastSubscription(byte[32])uint64[2]"
	method "getReceipt(uint64)uint64"
	method "getVault(uint64)uint64"
	method "getRecordReference(uint64,uint64,string)byte[32]"
	method "getMyTxnIDs(byte[32])uint64[]"
	method "getTxnInfo(uint64)(string,uint64,uint64)"
	txna ApplicationArgs 0
	match abi_route_subscribe abi_route_createRecord abi_route_makePayment abi_route_claimPayment abi_route_claimReceipt abi_route_getLastSubscription abi_route_getReceipt abi_route_getVault abi_route_getRecordReference abi_route_getMyTxnIDs abi_route_getTxnInfo
	err

intToAscii:
	proto 1 1
	byte 0x30313233343536373839 // "0123456789"
	frame_dig -1 // i: uint64
	int 1
	extract3
	retsub
	

itoa:
	proto 1 1
	frame_dig -1 // i: uint64
	int 0
	==
	bz itoa_if_end
	byte 0x151f7c75000130
	log
	retsub

itoa_if_end:
	frame_dig -1 // i: uint64
	int 10
	/
	int 0
	>
	bz itoa_ternary_false
	frame_dig -1 // i: uint64
	int 10
	/
	callsub itoa
	b itoa_ternary_end

itoa_ternary_false:
	byte 0x // ""

itoa_ternary_end:
	frame_dig -1 // i: uint64
	int 10
	%
	callsub intToAscii
	concat
	retsub

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub